package cmd

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"

	"github.com/spf13/cobra"
)

type MetaSchema struct {
	AgentMethods  map[string]string `json:"agentMethods"`
	ClientMethods map[string]string `json:"clientMethods"`
	Version       int               `json:"version"`
}

var constantsCmd = &cobra.Command{
	Use:   "constants",
	Short: "Generate constants from meta.json",
	Long:  `Generate Go constants from the meta.json schema file containing method names and protocol version.`,
	Run:   generateConstants,
}

func init() {
	rootCmd.AddCommand(constantsCmd)
}

func generateConstants(_ *cobra.Command, _ []string) {
	if err := doGenerateConstants(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func doGenerateConstants() error {
	// Read meta.json.
	file, err := os.Open("schema/meta.json")
	if err != nil {
		return fmt.Errorf("opening meta.json: %w", err)
	}
	defer file.Close()

	data, err := io.ReadAll(file)
	if err != nil {
		return fmt.Errorf("reading meta.json: %w", err)
	}

	var meta MetaSchema
	if unmarshalErr := json.Unmarshal(data, &meta); unmarshalErr != nil {
		return fmt.Errorf("parsing meta.json: %w", unmarshalErr)
	}

	// Generate constants file.
	output := strings.Builder{}
	output.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	output.WriteString("package api\n\n")

	// Agent method constants.
	if len(meta.AgentMethods) > 0 {
		output.WriteString("// Agent method constants\n")
		output.WriteString("const (\n")

		// Sort keys for consistent output
		agentKeys := make([]string, 0, len(meta.AgentMethods))
		for key := range meta.AgentMethods {
			agentKeys = append(agentKeys, key)
		}
		sort.Strings(agentKeys)

		for _, key := range agentKeys {
			value := meta.AgentMethods[key]
			constName := "Method" + toCamelCase(key)
			output.WriteString(fmt.Sprintf("\t%s = %q\n", constName, value))
		}
		output.WriteString(")\n\n")
	}

	// Client method constants.
	if len(meta.ClientMethods) > 0 {
		output.WriteString("// Client method constants\n")
		output.WriteString("const (\n")

		// Sort keys for consistent output
		clientKeys := make([]string, 0, len(meta.ClientMethods))
		for key := range meta.ClientMethods {
			clientKeys = append(clientKeys, key)
		}
		sort.Strings(clientKeys)

		for _, key := range clientKeys {
			value := meta.ClientMethods[key]
			constName := "Method" + toCamelCase(key)
			output.WriteString(fmt.Sprintf("\t%s = %q\n", constName, value))
		}
		output.WriteString(")\n\n")
	}

	// Protocol version constant.
	output.WriteString("// Protocol version\n")
	output.WriteString(fmt.Sprintf("const ACPProtocolVersion = %d\n", meta.Version))

	// Write to file.
	outputFile, err := os.Create("acp/api/constants_generated.go")
	if err != nil {
		return fmt.Errorf("creating constants file: %w", err)
	}
	defer outputFile.Close()

	if _, writeErr := outputFile.WriteString(output.String()); writeErr != nil {
		return fmt.Errorf("writing constants file: %w", writeErr)
	}

	fmt.Fprintf(os.Stderr, "Constants generated successfully in acp/api/constants_generated.go\n")
	return nil
}

// toCamelCase converts snake_case or kebab-case to CamelCase.
func toCamelCase(s string) string {
	parts := strings.FieldsFunc(s, func(c rune) bool {
		return c == '_' || c == '-' || c == '/'
	})

	result := ""
	for _, part := range parts {
		if len(part) > 0 {
			result += strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return result
}
