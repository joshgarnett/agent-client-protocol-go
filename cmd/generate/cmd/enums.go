package cmd

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/joshgarnett/agent-client-protocol-go/cmd/generate/internal"
	"github.com/spf13/cobra"
)

var enumsCmd = &cobra.Command{
	Use:   "enums",
	Short: "Generate enum types from schema",
	Long:  `Generate type-safe Go enums from oneOf string constants in the JSON schema.`,
	Run:   generateEnums,
}

func init() {
	rootCmd.AddCommand(enumsCmd)
}

func generateEnums(_ *cobra.Command, _ []string) {
	if err := doGenerateEnums(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func doGenerateEnums() error {
	parser, err := internal.NewSchemaParser("schema/schema.json")
	if err != nil {
		return fmt.Errorf("creating schema parser: %w", err)
	}

	enums, err := parser.FindEnums()
	if err != nil {
		return fmt.Errorf("finding enums: %w", err)
	}

	if len(enums) == 0 {
		fmt.Fprintf(os.Stderr, "No enums found in schema\n")
		return nil
	}

	// Generate code using template
	output := strings.Builder{}

	tmpl := template.Must(template.New("enums").Funcs(template.FuncMap{
		"toConstName": toEnumConstName,
		"sanitize":    sanitizeComment,
		"join":        strings.Join,
	}).Parse(enumTemplate))

	data := struct {
		Enums []internal.EnumDefinition
	}{
		Enums: enums,
	}

	if execErr := tmpl.Execute(&output, data); execErr != nil {
		return fmt.Errorf("executing template: %w", execErr)
	}

	// Write to file
	outputFile, err := os.Create("acp/api/enums_generated.go")
	if err != nil {
		return fmt.Errorf("creating enums file: %w", err)
	}
	defer outputFile.Close()

	if _, writeErr := outputFile.WriteString(output.String()); writeErr != nil {
		return fmt.Errorf("writing enums file: %w", writeErr)
	}

	fmt.Fprintf(os.Stderr, "Generated enums for %d types in acp/api/enums_generated.go\n", len(enums))
	return nil
}

// toEnumConstName converts an enum name and value to a Go constant name.
func toEnumConstName(enumName, value string) string {
	// Convert value to CamelCase and prepend enum name
	valueName := toCamelCase(value)
	if valueName == "" {
		valueName = "Empty"
	}

	// Handle special cases where value might start with number or be a Go keyword
	if len(valueName) > 0 && valueName[0] >= '0' && valueName[0] <= '9' {
		valueName = "Num" + valueName
	}

	return enumName + valueName
}

// sanitizeComment cleans up comments for Go code generation.
func sanitizeComment(comment string) string {
	// Remove extra whitespace and ensure proper formatting
	lines := strings.Split(strings.TrimSpace(comment), "\n")
	var cleanLines []string

	for _, line := range lines {
		clean := strings.TrimSpace(line)
		if clean != "" {
			cleanLines = append(cleanLines, clean)
		}
	}

	return strings.Join(cleanLines, " ")
}

const enumTemplate = `// Code generated by go generate; DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

{{range .Enums}}
{{$enumName := .Name}}
{{if .Description}}// {{sanitize .Description}}{{end}}
type {{.Name}} string

// {{.Name}} constants
const (
{{range .Values}}	{{toConstName $enumName .Value}} {{$enumName}} = "{{.Value}}"{{if .Description}} // {{sanitize .Description}}{{end}}
{{end}})

// IsValid returns true if the {{.Name}} value is valid.
func (e {{.Name}}) IsValid() bool {
	switch e {
	case {{range $i, $v := .Values}}{{if $i}}, {{end}}{{toConstName $enumName .Value}}{{end}}:
		return true
	default:
		return false
	}
}

// String returns the string representation of {{.Name}}.
func (e {{.Name}}) String() string {
	return string(e)
}

// MarshalJSON implements json.Marshaler for {{.Name}}.
func (e {{.Name}}) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid {{.Name}} value: %s", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler for {{.Name}}.
func (e *{{.Name}}) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	
	*e = {{.Name}}(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid {{.Name}} value: %s", s)
	}
	
	return nil
}

// All{{.Name}}Values returns all valid {{.Name}} values.
func All{{.Name}}Values() []{{.Name}} {
	return []{{.Name}}{
		{{range .Values}}{{toConstName $enumName .Value}},
		{{end}}
	}
}

{{end}}`
