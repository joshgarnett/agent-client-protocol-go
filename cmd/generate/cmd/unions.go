package cmd

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/joshgarnett/agent-client-protocol-go/cmd/generate/internal"
	"github.com/spf13/cobra"
)

var unionsCmd = &cobra.Command{
	Use:   "unions",
	Short: "Generate union types from schema",
	Long:  `Generate type-safe Go discriminated unions from oneOf patterns in the JSON schema.`,
	Run:   generateUnions,
}

func init() {
	rootCmd.AddCommand(unionsCmd)
}

func generateUnions(_ *cobra.Command, _ []string) {
	if err := doGenerateUnions(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func doGenerateUnions() error {
	parser, err := internal.NewSchemaParser("schema/schema.json")
	if err != nil {
		return fmt.Errorf("creating schema parser: %w", err)
	}

	unions, err := parser.FindUnions()
	if err != nil {
		return fmt.Errorf("finding unions: %w", err)
	}

	if len(unions) == 0 {
		fmt.Fprintf(os.Stderr, "No unions found in schema\n")
		return nil
	}

	// Generate code using template
	output := strings.Builder{}

	tmpl := template.Must(template.New("unions").Funcs(template.FuncMap{
		"toTypeName":        toUnionTypeName,
		"toConstName":       toUnionConstName,
		"toGetterName":      toGetterName,
		"toConstructor":     toConstructorName,
		"toCamelCase":       toCamelCase,
		"sanitize":          sanitizeComment,
		"hasContentField":   hasContentField,
		"getContentType":    getContentType,
		"join":              strings.Join,
		"constructorParams": buildConstructorParams,
	}).Parse(unionTemplate))

	data := struct {
		Unions []internal.UnionDefinition
	}{
		Unions: unions,
	}

	if execErr := tmpl.Execute(&output, data); execErr != nil {
		return fmt.Errorf("executing template: %w", execErr)
	}

	// Write to file
	outputFile, err := os.Create("acp/api/unions_generated.go")
	if err != nil {
		return fmt.Errorf("creating unions file: %w", err)
	}
	defer outputFile.Close()

	if _, writeErr := outputFile.WriteString(output.String()); writeErr != nil {
		return fmt.Errorf("writing unions file: %w", writeErr)
	}

	fmt.Fprintf(os.Stderr, "Generated unions for %d types in acp/api/unions_generated.go\n", len(unions))
	return nil
}

// toUnionTypeName converts union discriminator value to a type name.
func toUnionTypeName(unionName, value string) string {
	return unionName + "Type" + toCamelCase(value)
}

// toUnionConstName converts union discriminator value to a constant name.
func toUnionConstName(unionName, value string) string {
	return unionName + "Type" + toCamelCase(value)
}

// toGetterName creates a getter method name for a union variant.
func toGetterName(variantName string) string {
	return "Get" + variantName
}

// toConstructorName creates a constructor function name for a union variant.
func toConstructorName(unionName, variantName string) string {
	return "New" + unionName + variantName
}

// hasContentField checks if a variant has a ContentBlock field.
func hasContentField(variant internal.UnionVariant) bool {
	for propName, propDef := range variant.Properties {
		if propName == "content" {
			if propMap, ok := propDef.(map[string]interface{}); ok {
				if ref, hasRef := propMap["$ref"].(string); hasRef {
					return strings.Contains(ref, "ContentBlock")
				}
			}
		}
	}
	return false
}

// buildConstructorParams builds the parameter list for constructor functions.
func buildConstructorParams(_ string, sortedProps []internal.PropertyPair, discriminator string) string {
	var params []string

	for _, pair := range sortedProps {
		if pair.Name != discriminator {
			params = append(params, fmt.Sprintf("%s %s", pair.Name, getContentType(pair.Def)))
		}
	}

	return strings.Join(params, ", ")
}

// getContentType determines the Go type for a field based on schema reference.
func getContentType(propDef interface{}) string {
	if propMap, ok := propDef.(map[string]interface{}); ok {
		if ref, hasRef := propMap["$ref"].(string); hasRef {
			// Extract type name from $ref like "#/$defs/ContentBlock"
			parts := strings.Split(ref, "/")
			if len(parts) > 0 {
				return "*" + parts[len(parts)-1]
			}
		}
		if propType, hasType := propMap["type"].(string); hasType {
			switch propType {
			case "string":
				return "string"
			case "integer":
				return "int"
			case "boolean":
				return "bool"
			case "array":
				// Could be more sophisticated, but for now use interface{}
				return "[]interface{}"
			}
		}
	}
	return "interface{}"
}

const unionTemplate = `// Code generated by go generate; DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

{{range .Unions}}
{{$unionName := .Name}}
{{$discriminator := .Discriminator}}
{{if .Description}}// {{sanitize .Description}}{{end}}

// {{.Name}}Type represents the discriminator values for {{.Name}}.
type {{.Name}}Type string

// {{.Name}}Type constants
const (
{{range .Variants}}	{{toConstName $unionName .Value}} {{$unionName}}Type = "{{.Value}}"{{if .Description}} // {{sanitize .Description}}{{end}}
{{end}})

// IsValid returns true if the {{.Name}}Type value is valid.
func (t {{.Name}}Type) IsValid() bool {
	switch t {
	case {{range $i, $v := .Variants}}{{if $i}}, {{end}}{{toConstName $unionName .Value}}{{end}}:
		return true
	default:
		return false
	}
}

// {{.Name}} represents a discriminated union based on the {{.Discriminator}} field.
type {{.Name}} struct {
	Type {{.Name}}Type ` + "`json:\"{{.Discriminator}}\"`" + `
{{range .Variants}}
	{{.Name}} *{{$unionName}}{{.Name}} ` + "`json:\"-\"`" + `{{end}}
}

{{range .Variants}}
// {{$unionName}}{{.Name}} represents the {{.Value}} variant of {{$unionName}}.
type {{$unionName}}{{.Name}} struct {
{{range $propName, $propDef := .Properties}}{{if ne $propName $discriminator}}	{{toCamelCase $propName}} {{getContentType $propDef}} ` + "`json:\"{{$propName}},omitempty\"`" + `
{{end}}{{end}}}

{{end}}

// MarshalJSON implements json.Marshaler for {{.Name}}.
func (u {{.Name}}) MarshalJSON() ([]byte, error) {
	if !u.Type.IsValid() {
		return nil, fmt.Errorf("invalid {{.Name}} type: %s", string(u.Type))
	}

	switch u.Type {
{{range .Variants}}	case {{toConstName $unionName .Value}}:
		if u.{{.Name}} == nil {
			return nil, fmt.Errorf("{{.Name}} field is required for type {{.Value}}")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type {{$unionName}}Type ` + "`json:\"{{$discriminator}}\"`" + `
			*{{$unionName}}{{.Name}}
		}{
			Type: u.Type,
			{{$unionName}}{{.Name}}: u.{{.Name}},
		}
		return json.Marshal(temp)
{{end}}	default:
		return nil, fmt.Errorf("unknown {{.Name}} type: %s", string(u.Type))
	}
}

// UnmarshalJSON implements json.Unmarshaler for {{.Name}}.
func (u *{{.Name}}) UnmarshalJSON(data []byte) error {
	// First, unmarshal just the discriminator to determine the type
	var discriminator struct {
		Type {{.Name}}Type ` + "`json:\"{{$discriminator}}\"`" + `
	}
	
	if err := json.Unmarshal(data, &discriminator); err != nil {
		return fmt.Errorf("failed to unmarshal {{$discriminator}} field: %w", err)
	}
	
	if !discriminator.Type.IsValid() {
		return fmt.Errorf("invalid {{.Name}} type: %s", string(discriminator.Type))
	}
	
	u.Type = discriminator.Type
	
	// Now unmarshal the specific variant
	switch u.Type {
{{range .Variants}}	case {{toConstName $unionName .Value}}:
		var variant {{$unionName}}{{.Name}}
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal {{.Value}} variant: %w", err)
		}
		u.{{.Name}} = &variant
{{end}}	default:
		return fmt.Errorf("unknown {{.Name}} type: %s", string(u.Type))
	}
	
	return nil
}

{{range .Variants}}
// {{toGetterName .Name}} returns the {{.Name}} variant if this is a {{.Value}} type.
func (u *{{$unionName}}) {{toGetterName .Name}}() *{{$unionName}}{{.Name}} {
	if u.Type == {{toConstName $unionName .Value}} {
		return u.{{.Name}}
	}
	return nil
}

// {{toConstructor $unionName .Name}} creates a new {{$unionName}} with {{.Value}} type.
func {{toConstructor $unionName .Name}}({{constructorParams $unionName .SortedProperties $discriminator}}) *{{$unionName}} {
	return &{{$unionName}}{
		Type: {{toConstName $unionName .Value}},
		{{.Name}}: &{{$unionName}}{{.Name}}{
{{range $propName, $propDef := .Properties}}{{if ne $propName $discriminator}}			{{toCamelCase $propName}}: {{$propName}},
{{end}}{{end}}		},
	}
}

{{end}}

// Is{{.Name}} returns true if this is a {{.Name}} of the specified type.
func (u *{{.Name}}) Is{{.Name}}(t {{.Name}}Type) bool {
	return u.Type == t
}

{{end}}`
