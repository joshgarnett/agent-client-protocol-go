// Code generated by go generate; DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// Content blocks represent displayable information in the Agent Client Protocol. They provide a structured way to handle various types of user-facing contentâ€”whether it's text from language models, images for analysis, or embedded resources for context. Content blocks appear in: - User prompts sent via `session/prompt` - Language model output streamed through `session/update` notifications - Progress updates and results from tool calls This structure is compatible with the Model Context Protocol (MCP), enabling agents to seamlessly forward content from MCP tool outputs without transformation. See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)

// ContentBlockType represents the discriminator values for ContentBlock.
type ContentBlockType string

// ContentBlockType constants
const (
	ContentBlockTypeAudio        ContentBlockType = "audio"         // Audio data for transcription or analysis. Requires the `audio` prompt capability when included in prompts.
	ContentBlockTypeImage        ContentBlockType = "image"         // Images for visual context or analysis. Requires the `image` prompt capability when included in prompts.
	ContentBlockTypeResource     ContentBlockType = "resource"      // Complete resource contents embedded directly in the message. Preferred for including context as it avoids extra round-trips. Requires the `embeddedContext` prompt capability when included in prompts.
	ContentBlockTypeResourceLink ContentBlockType = "resource_link" // References to resources that the agent can access. All agents MUST support resource links in prompts.
	ContentBlockTypeText         ContentBlockType = "text"          // Plain text content All agents MUST support text content blocks in prompts.
)

// IsValid returns true if the ContentBlockType value is valid.
func (t ContentBlockType) IsValid() bool {
	switch t {
	case ContentBlockTypeAudio, ContentBlockTypeImage, ContentBlockTypeResource, ContentBlockTypeResourceLink, ContentBlockTypeText:
		return true
	default:
		return false
	}
}

// ContentBlock represents a discriminated union based on the type field.
type ContentBlock struct {
	Type ContentBlockType `json:"type"`

	Audio        *ContentBlockAudio        `json:"-"`
	Image        *ContentBlockImage        `json:"-"`
	Resource     *ContentBlockResource     `json:"-"`
	ResourceLink *ContentBlockResourceLink `json:"-"`
	Text         *ContentBlockText         `json:"-"`
}

// ContentBlockAudio represents the audio variant of ContentBlock.
type ContentBlockAudio struct {
	Annotations interface{} `json:"annotations,omitempty"`
	Data        string      `json:"data,omitempty"`
	Mimetype    string      `json:"mimeType,omitempty"`
}

// ContentBlockImage represents the image variant of ContentBlock.
type ContentBlockImage struct {
	Annotations interface{} `json:"annotations,omitempty"`
	Data        string      `json:"data,omitempty"`
	Mimetype    string      `json:"mimeType,omitempty"`
	Uri         interface{} `json:"uri,omitempty"`
}

// ContentBlockResource represents the resource variant of ContentBlock.
type ContentBlockResource struct {
	Annotations interface{}               `json:"annotations,omitempty"`
	Resource    *EmbeddedResourceResource `json:"resource,omitempty"`
}

// ContentBlockResourceLink represents the resource_link variant of ContentBlock.
type ContentBlockResourceLink struct {
	Annotations interface{} `json:"annotations,omitempty"`
	Description interface{} `json:"description,omitempty"`
	Mimetype    interface{} `json:"mimeType,omitempty"`
	Name        string      `json:"name,omitempty"`
	Size        interface{} `json:"size,omitempty"`
	Title       interface{} `json:"title,omitempty"`
	Uri         string      `json:"uri,omitempty"`
}

// ContentBlockText represents the text variant of ContentBlock.
type ContentBlockText struct {
	Annotations interface{} `json:"annotations,omitempty"`
	Text        string      `json:"text,omitempty"`
}

// MarshalJSON implements json.Marshaler for ContentBlock.
func (u ContentBlock) MarshalJSON() ([]byte, error) {
	if !u.Type.IsValid() {
		return nil, fmt.Errorf("invalid ContentBlock type: %s", string(u.Type))
	}

	switch u.Type {
	case ContentBlockTypeAudio:
		if u.Audio == nil {
			return nil, fmt.Errorf("Audio field is required for type audio")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ContentBlockType `json:"type"`
			*ContentBlockAudio
		}{
			Type:              u.Type,
			ContentBlockAudio: u.Audio,
		}
		return json.Marshal(temp)
	case ContentBlockTypeImage:
		if u.Image == nil {
			return nil, fmt.Errorf("Image field is required for type image")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ContentBlockType `json:"type"`
			*ContentBlockImage
		}{
			Type:              u.Type,
			ContentBlockImage: u.Image,
		}
		return json.Marshal(temp)
	case ContentBlockTypeResource:
		if u.Resource == nil {
			return nil, fmt.Errorf("Resource field is required for type resource")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ContentBlockType `json:"type"`
			*ContentBlockResource
		}{
			Type:                 u.Type,
			ContentBlockResource: u.Resource,
		}
		return json.Marshal(temp)
	case ContentBlockTypeResourceLink:
		if u.ResourceLink == nil {
			return nil, fmt.Errorf("ResourceLink field is required for type resource_link")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ContentBlockType `json:"type"`
			*ContentBlockResourceLink
		}{
			Type:                     u.Type,
			ContentBlockResourceLink: u.ResourceLink,
		}
		return json.Marshal(temp)
	case ContentBlockTypeText:
		if u.Text == nil {
			return nil, fmt.Errorf("Text field is required for type text")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ContentBlockType `json:"type"`
			*ContentBlockText
		}{
			Type:             u.Type,
			ContentBlockText: u.Text,
		}
		return json.Marshal(temp)
	default:
		return nil, fmt.Errorf("unknown ContentBlock type: %s", string(u.Type))
	}
}

// UnmarshalJSON implements json.Unmarshaler for ContentBlock.
func (u *ContentBlock) UnmarshalJSON(data []byte) error {
	// First, unmarshal just the discriminator to determine the type
	var discriminator struct {
		Type ContentBlockType `json:"type"`
	}

	if err := json.Unmarshal(data, &discriminator); err != nil {
		return fmt.Errorf("failed to unmarshal type field: %w", err)
	}

	if !discriminator.Type.IsValid() {
		return fmt.Errorf("invalid ContentBlock type: %s", string(discriminator.Type))
	}

	u.Type = discriminator.Type

	// Now unmarshal the specific variant
	switch u.Type {
	case ContentBlockTypeAudio:
		var variant ContentBlockAudio
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal audio variant: %w", err)
		}
		u.Audio = &variant
	case ContentBlockTypeImage:
		var variant ContentBlockImage
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal image variant: %w", err)
		}
		u.Image = &variant
	case ContentBlockTypeResource:
		var variant ContentBlockResource
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal resource variant: %w", err)
		}
		u.Resource = &variant
	case ContentBlockTypeResourceLink:
		var variant ContentBlockResourceLink
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal resource_link variant: %w", err)
		}
		u.ResourceLink = &variant
	case ContentBlockTypeText:
		var variant ContentBlockText
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal text variant: %w", err)
		}
		u.Text = &variant
	default:
		return fmt.Errorf("unknown ContentBlock type: %s", string(u.Type))
	}

	return nil
}

// GetAudio returns the Audio variant if this is a audio type.
func (u *ContentBlock) GetAudio() *ContentBlockAudio {
	if u.Type == ContentBlockTypeAudio {
		return u.Audio
	}
	return nil
}

// NewContentBlockAudio creates a new ContentBlock with audio type.
func NewContentBlockAudio(annotations interface{}, data string, mimeType string) *ContentBlock {
	return &ContentBlock{
		Type: ContentBlockTypeAudio,
		Audio: &ContentBlockAudio{
			Annotations: annotations,
			Data:        data,
			Mimetype:    mimeType,
		},
	}
}

// GetImage returns the Image variant if this is a image type.
func (u *ContentBlock) GetImage() *ContentBlockImage {
	if u.Type == ContentBlockTypeImage {
		return u.Image
	}
	return nil
}

// NewContentBlockImage creates a new ContentBlock with image type.
func NewContentBlockImage(annotations interface{}, data string, mimeType string, uri interface{}) *ContentBlock {
	return &ContentBlock{
		Type: ContentBlockTypeImage,
		Image: &ContentBlockImage{
			Annotations: annotations,
			Data:        data,
			Mimetype:    mimeType,
			Uri:         uri,
		},
	}
}

// GetResource returns the Resource variant if this is a resource type.
func (u *ContentBlock) GetResource() *ContentBlockResource {
	if u.Type == ContentBlockTypeResource {
		return u.Resource
	}
	return nil
}

// NewContentBlockResource creates a new ContentBlock with resource type.
func NewContentBlockResource(annotations interface{}, resource *EmbeddedResourceResource) *ContentBlock {
	return &ContentBlock{
		Type: ContentBlockTypeResource,
		Resource: &ContentBlockResource{
			Annotations: annotations,
			Resource:    resource,
		},
	}
}

// GetResourceLink returns the ResourceLink variant if this is a resource_link type.
func (u *ContentBlock) GetResourceLink() *ContentBlockResourceLink {
	if u.Type == ContentBlockTypeResourceLink {
		return u.ResourceLink
	}
	return nil
}

// NewContentBlockResourceLink creates a new ContentBlock with resource_link type.
func NewContentBlockResourceLink(annotations interface{}, description interface{}, mimeType interface{}, name string, size interface{}, title interface{}, uri string) *ContentBlock {
	return &ContentBlock{
		Type: ContentBlockTypeResourceLink,
		ResourceLink: &ContentBlockResourceLink{
			Annotations: annotations,
			Description: description,
			Mimetype:    mimeType,
			Name:        name,
			Size:        size,
			Title:       title,
			Uri:         uri,
		},
	}
}

// GetText returns the Text variant if this is a text type.
func (u *ContentBlock) GetText() *ContentBlockText {
	if u.Type == ContentBlockTypeText {
		return u.Text
	}
	return nil
}

// NewContentBlockText creates a new ContentBlock with text type.
func NewContentBlockText(annotations interface{}, text string) *ContentBlock {
	return &ContentBlock{
		Type: ContentBlockTypeText,
		Text: &ContentBlockText{
			Annotations: annotations,
			Text:        text,
		},
	}
}

// IsContentBlock returns true if this is a ContentBlock of the specified type.
func (u *ContentBlock) IsContentBlock(t ContentBlockType) bool {
	return u.Type == t
}

// Different types of updates that can be sent during session processing. These updates provide real-time feedback about the agent's progress. See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)

// SessionUpdateType represents the discriminator values for SessionUpdate.
type SessionUpdateType string

// SessionUpdateType constants
const (
	SessionUpdateTypeAgentMessageChunk SessionUpdateType = "agent_message_chunk" // A chunk of the agent's response being streamed.
	SessionUpdateTypeAgentThoughtChunk SessionUpdateType = "agent_thought_chunk" // A chunk of the agent's internal reasoning being streamed.
	SessionUpdateTypePlan              SessionUpdateType = "plan"                // The agent's execution plan for complex tasks. See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
	SessionUpdateTypeToolCall          SessionUpdateType = "tool_call"           // Notification that a new tool call has been initiated.
	SessionUpdateTypeToolCallUpdate    SessionUpdateType = "tool_call_update"    // Update on the status or results of a tool call.
	SessionUpdateTypeUserMessageChunk  SessionUpdateType = "user_message_chunk"  // A chunk of the user's message being streamed.
)

// IsValid returns true if the SessionUpdateType value is valid.
func (t SessionUpdateType) IsValid() bool {
	switch t {
	case SessionUpdateTypeAgentMessageChunk, SessionUpdateTypeAgentThoughtChunk, SessionUpdateTypePlan, SessionUpdateTypeToolCall, SessionUpdateTypeToolCallUpdate, SessionUpdateTypeUserMessageChunk:
		return true
	default:
		return false
	}
}

// SessionUpdate represents a discriminated union based on the sessionUpdate field.
type SessionUpdate struct {
	Type SessionUpdateType `json:"sessionUpdate"`

	AgentMessageChunk *SessionUpdateAgentMessageChunk `json:"-"`
	AgentThoughtChunk *SessionUpdateAgentThoughtChunk `json:"-"`
	Plan              *SessionUpdatePlan              `json:"-"`
	ToolCall          *SessionUpdateToolCall          `json:"-"`
	ToolCallUpdate    *SessionUpdateToolCallUpdate    `json:"-"`
	UserMessageChunk  *SessionUpdateUserMessageChunk  `json:"-"`
}

// SessionUpdateAgentMessageChunk represents the agent_message_chunk variant of SessionUpdate.
type SessionUpdateAgentMessageChunk struct {
	Content *ContentBlock `json:"content,omitempty"`
}

// SessionUpdateAgentThoughtChunk represents the agent_thought_chunk variant of SessionUpdate.
type SessionUpdateAgentThoughtChunk struct {
	Content *ContentBlock `json:"content,omitempty"`
}

// SessionUpdatePlan represents the plan variant of SessionUpdate.
type SessionUpdatePlan struct {
	Entries []interface{} `json:"entries,omitempty"`
}

// SessionUpdateToolCall represents the tool_call variant of SessionUpdate.
type SessionUpdateToolCall struct {
	Content    []interface{}   `json:"content,omitempty"`
	Kind       *ToolKind       `json:"kind,omitempty"`
	Locations  []interface{}   `json:"locations,omitempty"`
	Rawinput   interface{}     `json:"rawInput,omitempty"`
	Rawoutput  interface{}     `json:"rawOutput,omitempty"`
	Status     *ToolCallStatus `json:"status,omitempty"`
	Title      string          `json:"title,omitempty"`
	Toolcallid *ToolCallId     `json:"toolCallId,omitempty"`
}

// SessionUpdateToolCallUpdate represents the tool_call_update variant of SessionUpdate.
type SessionUpdateToolCallUpdate struct {
	Content    interface{} `json:"content,omitempty"`
	Kind       interface{} `json:"kind,omitempty"`
	Locations  interface{} `json:"locations,omitempty"`
	Rawinput   interface{} `json:"rawInput,omitempty"`
	Rawoutput  interface{} `json:"rawOutput,omitempty"`
	Status     interface{} `json:"status,omitempty"`
	Title      interface{} `json:"title,omitempty"`
	Toolcallid *ToolCallId `json:"toolCallId,omitempty"`
}

// SessionUpdateUserMessageChunk represents the user_message_chunk variant of SessionUpdate.
type SessionUpdateUserMessageChunk struct {
	Content *ContentBlock `json:"content,omitempty"`
}

// MarshalJSON implements json.Marshaler for SessionUpdate.
func (u SessionUpdate) MarshalJSON() ([]byte, error) {
	if !u.Type.IsValid() {
		return nil, fmt.Errorf("invalid SessionUpdate type: %s", string(u.Type))
	}

	switch u.Type {
	case SessionUpdateTypeAgentMessageChunk:
		if u.AgentMessageChunk == nil {
			return nil, fmt.Errorf("AgentMessageChunk field is required for type agent_message_chunk")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type SessionUpdateType `json:"sessionUpdate"`
			*SessionUpdateAgentMessageChunk
		}{
			Type:                           u.Type,
			SessionUpdateAgentMessageChunk: u.AgentMessageChunk,
		}
		return json.Marshal(temp)
	case SessionUpdateTypeAgentThoughtChunk:
		if u.AgentThoughtChunk == nil {
			return nil, fmt.Errorf("AgentThoughtChunk field is required for type agent_thought_chunk")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type SessionUpdateType `json:"sessionUpdate"`
			*SessionUpdateAgentThoughtChunk
		}{
			Type:                           u.Type,
			SessionUpdateAgentThoughtChunk: u.AgentThoughtChunk,
		}
		return json.Marshal(temp)
	case SessionUpdateTypePlan:
		if u.Plan == nil {
			return nil, fmt.Errorf("Plan field is required for type plan")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type SessionUpdateType `json:"sessionUpdate"`
			*SessionUpdatePlan
		}{
			Type:              u.Type,
			SessionUpdatePlan: u.Plan,
		}
		return json.Marshal(temp)
	case SessionUpdateTypeToolCall:
		if u.ToolCall == nil {
			return nil, fmt.Errorf("ToolCall field is required for type tool_call")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type SessionUpdateType `json:"sessionUpdate"`
			*SessionUpdateToolCall
		}{
			Type:                  u.Type,
			SessionUpdateToolCall: u.ToolCall,
		}
		return json.Marshal(temp)
	case SessionUpdateTypeToolCallUpdate:
		if u.ToolCallUpdate == nil {
			return nil, fmt.Errorf("ToolCallUpdate field is required for type tool_call_update")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type SessionUpdateType `json:"sessionUpdate"`
			*SessionUpdateToolCallUpdate
		}{
			Type:                        u.Type,
			SessionUpdateToolCallUpdate: u.ToolCallUpdate,
		}
		return json.Marshal(temp)
	case SessionUpdateTypeUserMessageChunk:
		if u.UserMessageChunk == nil {
			return nil, fmt.Errorf("UserMessageChunk field is required for type user_message_chunk")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type SessionUpdateType `json:"sessionUpdate"`
			*SessionUpdateUserMessageChunk
		}{
			Type:                          u.Type,
			SessionUpdateUserMessageChunk: u.UserMessageChunk,
		}
		return json.Marshal(temp)
	default:
		return nil, fmt.Errorf("unknown SessionUpdate type: %s", string(u.Type))
	}
}

// UnmarshalJSON implements json.Unmarshaler for SessionUpdate.
func (u *SessionUpdate) UnmarshalJSON(data []byte) error {
	// First, unmarshal just the discriminator to determine the type
	var discriminator struct {
		Type SessionUpdateType `json:"sessionUpdate"`
	}

	if err := json.Unmarshal(data, &discriminator); err != nil {
		return fmt.Errorf("failed to unmarshal sessionUpdate field: %w", err)
	}

	if !discriminator.Type.IsValid() {
		return fmt.Errorf("invalid SessionUpdate type: %s", string(discriminator.Type))
	}

	u.Type = discriminator.Type

	// Now unmarshal the specific variant
	switch u.Type {
	case SessionUpdateTypeAgentMessageChunk:
		var variant SessionUpdateAgentMessageChunk
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal agent_message_chunk variant: %w", err)
		}
		u.AgentMessageChunk = &variant
	case SessionUpdateTypeAgentThoughtChunk:
		var variant SessionUpdateAgentThoughtChunk
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal agent_thought_chunk variant: %w", err)
		}
		u.AgentThoughtChunk = &variant
	case SessionUpdateTypePlan:
		var variant SessionUpdatePlan
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal plan variant: %w", err)
		}
		u.Plan = &variant
	case SessionUpdateTypeToolCall:
		var variant SessionUpdateToolCall
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal tool_call variant: %w", err)
		}
		u.ToolCall = &variant
	case SessionUpdateTypeToolCallUpdate:
		var variant SessionUpdateToolCallUpdate
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal tool_call_update variant: %w", err)
		}
		u.ToolCallUpdate = &variant
	case SessionUpdateTypeUserMessageChunk:
		var variant SessionUpdateUserMessageChunk
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal user_message_chunk variant: %w", err)
		}
		u.UserMessageChunk = &variant
	default:
		return fmt.Errorf("unknown SessionUpdate type: %s", string(u.Type))
	}

	return nil
}

// GetAgentMessageChunk returns the AgentMessageChunk variant if this is a agent_message_chunk type.
func (u *SessionUpdate) GetAgentMessageChunk() *SessionUpdateAgentMessageChunk {
	if u.Type == SessionUpdateTypeAgentMessageChunk {
		return u.AgentMessageChunk
	}
	return nil
}

// NewSessionUpdateAgentMessageChunk creates a new SessionUpdate with agent_message_chunk type.
func NewSessionUpdateAgentMessageChunk(content *ContentBlock) *SessionUpdate {
	return &SessionUpdate{
		Type: SessionUpdateTypeAgentMessageChunk,
		AgentMessageChunk: &SessionUpdateAgentMessageChunk{
			Content: content,
		},
	}
}

// GetAgentThoughtChunk returns the AgentThoughtChunk variant if this is a agent_thought_chunk type.
func (u *SessionUpdate) GetAgentThoughtChunk() *SessionUpdateAgentThoughtChunk {
	if u.Type == SessionUpdateTypeAgentThoughtChunk {
		return u.AgentThoughtChunk
	}
	return nil
}

// NewSessionUpdateAgentThoughtChunk creates a new SessionUpdate with agent_thought_chunk type.
func NewSessionUpdateAgentThoughtChunk(content *ContentBlock) *SessionUpdate {
	return &SessionUpdate{
		Type: SessionUpdateTypeAgentThoughtChunk,
		AgentThoughtChunk: &SessionUpdateAgentThoughtChunk{
			Content: content,
		},
	}
}

// GetPlan returns the Plan variant if this is a plan type.
func (u *SessionUpdate) GetPlan() *SessionUpdatePlan {
	if u.Type == SessionUpdateTypePlan {
		return u.Plan
	}
	return nil
}

// NewSessionUpdatePlan creates a new SessionUpdate with plan type.
func NewSessionUpdatePlan(entries []interface{}) *SessionUpdate {
	return &SessionUpdate{
		Type: SessionUpdateTypePlan,
		Plan: &SessionUpdatePlan{
			Entries: entries,
		},
	}
}

// GetToolCall returns the ToolCall variant if this is a tool_call type.
func (u *SessionUpdate) GetToolCall() *SessionUpdateToolCall {
	if u.Type == SessionUpdateTypeToolCall {
		return u.ToolCall
	}
	return nil
}

// NewSessionUpdateToolCall creates a new SessionUpdate with tool_call type.
func NewSessionUpdateToolCall(content []interface{}, kind *ToolKind, locations []interface{}, rawInput interface{}, rawOutput interface{}, status *ToolCallStatus, title string, toolCallId *ToolCallId) *SessionUpdate {
	return &SessionUpdate{
		Type: SessionUpdateTypeToolCall,
		ToolCall: &SessionUpdateToolCall{
			Content:    content,
			Kind:       kind,
			Locations:  locations,
			Rawinput:   rawInput,
			Rawoutput:  rawOutput,
			Status:     status,
			Title:      title,
			Toolcallid: toolCallId,
		},
	}
}

// GetToolCallUpdate returns the ToolCallUpdate variant if this is a tool_call_update type.
func (u *SessionUpdate) GetToolCallUpdate() *SessionUpdateToolCallUpdate {
	if u.Type == SessionUpdateTypeToolCallUpdate {
		return u.ToolCallUpdate
	}
	return nil
}

// NewSessionUpdateToolCallUpdate creates a new SessionUpdate with tool_call_update type.
func NewSessionUpdateToolCallUpdate(content interface{}, kind interface{}, locations interface{}, rawInput interface{}, rawOutput interface{}, status interface{}, title interface{}, toolCallId *ToolCallId) *SessionUpdate {
	return &SessionUpdate{
		Type: SessionUpdateTypeToolCallUpdate,
		ToolCallUpdate: &SessionUpdateToolCallUpdate{
			Content:    content,
			Kind:       kind,
			Locations:  locations,
			Rawinput:   rawInput,
			Rawoutput:  rawOutput,
			Status:     status,
			Title:      title,
			Toolcallid: toolCallId,
		},
	}
}

// GetUserMessageChunk returns the UserMessageChunk variant if this is a user_message_chunk type.
func (u *SessionUpdate) GetUserMessageChunk() *SessionUpdateUserMessageChunk {
	if u.Type == SessionUpdateTypeUserMessageChunk {
		return u.UserMessageChunk
	}
	return nil
}

// NewSessionUpdateUserMessageChunk creates a new SessionUpdate with user_message_chunk type.
func NewSessionUpdateUserMessageChunk(content *ContentBlock) *SessionUpdate {
	return &SessionUpdate{
		Type: SessionUpdateTypeUserMessageChunk,
		UserMessageChunk: &SessionUpdateUserMessageChunk{
			Content: content,
		},
	}
}

// IsSessionUpdate returns true if this is a SessionUpdate of the specified type.
func (u *SessionUpdate) IsSessionUpdate(t SessionUpdateType) bool {
	return u.Type == t
}

// Content produced by a tool call. Tool calls can produce different types of content including standard content blocks (text, images) or file diffs. See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)

// ToolCallContentType represents the discriminator values for ToolCallContent.
type ToolCallContentType string

// ToolCallContentType constants
const (
	ToolCallContentTypeContent  ToolCallContentType = "content" // Standard content block (text, images, resources).
	ToolCallContentTypeDiff     ToolCallContentType = "diff"    // File modification shown as a diff.
	ToolCallContentTypeTerminal ToolCallContentType = "terminal"
)

// IsValid returns true if the ToolCallContentType value is valid.
func (t ToolCallContentType) IsValid() bool {
	switch t {
	case ToolCallContentTypeContent, ToolCallContentTypeDiff, ToolCallContentTypeTerminal:
		return true
	default:
		return false
	}
}

// ToolCallContent represents a discriminated union based on the type field.
type ToolCallContent struct {
	Type ToolCallContentType `json:"type"`

	Content  *ToolCallContentContent  `json:"-"`
	Diff     *ToolCallContentDiff     `json:"-"`
	Terminal *ToolCallContentTerminal `json:"-"`
}

// ToolCallContentContent represents the content variant of ToolCallContent.
type ToolCallContentContent struct {
	Content *ContentBlock `json:"content,omitempty"`
}

// ToolCallContentDiff represents the diff variant of ToolCallContent.
type ToolCallContentDiff struct {
	Newtext string      `json:"newText,omitempty"`
	Oldtext interface{} `json:"oldText,omitempty"`
	Path    string      `json:"path,omitempty"`
}

// ToolCallContentTerminal represents the terminal variant of ToolCallContent.
type ToolCallContentTerminal struct {
	Terminalid string `json:"terminalId,omitempty"`
}

// MarshalJSON implements json.Marshaler for ToolCallContent.
func (u ToolCallContent) MarshalJSON() ([]byte, error) {
	if !u.Type.IsValid() {
		return nil, fmt.Errorf("invalid ToolCallContent type: %s", string(u.Type))
	}

	switch u.Type {
	case ToolCallContentTypeContent:
		if u.Content == nil {
			return nil, fmt.Errorf("Content field is required for type content")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ToolCallContentType `json:"type"`
			*ToolCallContentContent
		}{
			Type:                   u.Type,
			ToolCallContentContent: u.Content,
		}
		return json.Marshal(temp)
	case ToolCallContentTypeDiff:
		if u.Diff == nil {
			return nil, fmt.Errorf("Diff field is required for type diff")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ToolCallContentType `json:"type"`
			*ToolCallContentDiff
		}{
			Type:                u.Type,
			ToolCallContentDiff: u.Diff,
		}
		return json.Marshal(temp)
	case ToolCallContentTypeTerminal:
		if u.Terminal == nil {
			return nil, fmt.Errorf("Terminal field is required for type terminal")
		}
		// Create a temporary struct that includes the discriminator
		temp := struct {
			Type ToolCallContentType `json:"type"`
			*ToolCallContentTerminal
		}{
			Type:                    u.Type,
			ToolCallContentTerminal: u.Terminal,
		}
		return json.Marshal(temp)
	default:
		return nil, fmt.Errorf("unknown ToolCallContent type: %s", string(u.Type))
	}
}

// UnmarshalJSON implements json.Unmarshaler for ToolCallContent.
func (u *ToolCallContent) UnmarshalJSON(data []byte) error {
	// First, unmarshal just the discriminator to determine the type
	var discriminator struct {
		Type ToolCallContentType `json:"type"`
	}

	if err := json.Unmarshal(data, &discriminator); err != nil {
		return fmt.Errorf("failed to unmarshal type field: %w", err)
	}

	if !discriminator.Type.IsValid() {
		return fmt.Errorf("invalid ToolCallContent type: %s", string(discriminator.Type))
	}

	u.Type = discriminator.Type

	// Now unmarshal the specific variant
	switch u.Type {
	case ToolCallContentTypeContent:
		var variant ToolCallContentContent
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal content variant: %w", err)
		}
		u.Content = &variant
	case ToolCallContentTypeDiff:
		var variant ToolCallContentDiff
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal diff variant: %w", err)
		}
		u.Diff = &variant
	case ToolCallContentTypeTerminal:
		var variant ToolCallContentTerminal
		if err := json.Unmarshal(data, &variant); err != nil {
			return fmt.Errorf("failed to unmarshal terminal variant: %w", err)
		}
		u.Terminal = &variant
	default:
		return fmt.Errorf("unknown ToolCallContent type: %s", string(u.Type))
	}

	return nil
}

// GetContent returns the Content variant if this is a content type.
func (u *ToolCallContent) GetContent() *ToolCallContentContent {
	if u.Type == ToolCallContentTypeContent {
		return u.Content
	}
	return nil
}

// NewToolCallContentContent creates a new ToolCallContent with content type.
func NewToolCallContentContent(content *ContentBlock) *ToolCallContent {
	return &ToolCallContent{
		Type: ToolCallContentTypeContent,
		Content: &ToolCallContentContent{
			Content: content,
		},
	}
}

// GetDiff returns the Diff variant if this is a diff type.
func (u *ToolCallContent) GetDiff() *ToolCallContentDiff {
	if u.Type == ToolCallContentTypeDiff {
		return u.Diff
	}
	return nil
}

// NewToolCallContentDiff creates a new ToolCallContent with diff type.
func NewToolCallContentDiff(newText string, oldText interface{}, path string) *ToolCallContent {
	return &ToolCallContent{
		Type: ToolCallContentTypeDiff,
		Diff: &ToolCallContentDiff{
			Newtext: newText,
			Oldtext: oldText,
			Path:    path,
		},
	}
}

// GetTerminal returns the Terminal variant if this is a terminal type.
func (u *ToolCallContent) GetTerminal() *ToolCallContentTerminal {
	if u.Type == ToolCallContentTypeTerminal {
		return u.Terminal
	}
	return nil
}

// NewToolCallContentTerminal creates a new ToolCallContent with terminal type.
func NewToolCallContentTerminal(terminalId string) *ToolCallContent {
	return &ToolCallContent{
		Type: ToolCallContentTypeTerminal,
		Terminal: &ToolCallContentTerminal{
			Terminalid: terminalId,
		},
	}
}

// IsToolCallContent returns true if this is a ToolCallContent of the specified type.
func (u *ToolCallContent) IsToolCallContent(t ToolCallContentType) bool {
	return u.Type == t
}
