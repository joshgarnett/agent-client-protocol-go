// Code generated by go generate; DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// The type of permission option being presented to the user. Helps clients choose appropriate icons and UI treatment.
type PermissionOptionKind string

// PermissionOptionKind constants
const (
	PermissionOptionKindAllowAlways  PermissionOptionKind = "allow_always"  // Allow this operation and remember the choice.
	PermissionOptionKindAllowOnce    PermissionOptionKind = "allow_once"    // Allow this operation only this time.
	PermissionOptionKindRejectAlways PermissionOptionKind = "reject_always" // Reject this operation and remember the choice.
	PermissionOptionKindRejectOnce   PermissionOptionKind = "reject_once"   // Reject this operation only this time.
)

// IsValid returns true if the PermissionOptionKind value is valid.
func (e PermissionOptionKind) IsValid() bool {
	switch e {
	case PermissionOptionKindAllowAlways, PermissionOptionKindAllowOnce, PermissionOptionKindRejectAlways, PermissionOptionKindRejectOnce:
		return true
	default:
		return false
	}
}

// String returns the string representation of PermissionOptionKind.
func (e PermissionOptionKind) String() string {
	return string(e)
}

// MarshalJSON implements json.Marshaler for PermissionOptionKind.
func (e PermissionOptionKind) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid PermissionOptionKind value: %s", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler for PermissionOptionKind.
func (e *PermissionOptionKind) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	*e = PermissionOptionKind(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid PermissionOptionKind value: %s", s)
	}

	return nil
}

// AllPermissionOptionKindValues returns all valid PermissionOptionKind values.
func AllPermissionOptionKindValues() []PermissionOptionKind {
	return []PermissionOptionKind{
		PermissionOptionKindAllowAlways,
		PermissionOptionKindAllowOnce,
		PermissionOptionKindRejectAlways,
		PermissionOptionKindRejectOnce,
	}
}

// Priority levels for plan entries. Used to indicate the relative importance or urgency of different tasks in the execution plan. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryPriority string

// PlanEntryPriority constants
const (
	PlanEntryPriorityHigh   PlanEntryPriority = "high"   // High priority task - critical to the overall goal.
	PlanEntryPriorityLow    PlanEntryPriority = "low"    // Low priority task - nice to have but not essential.
	PlanEntryPriorityMedium PlanEntryPriority = "medium" // Medium priority task - important but not critical.
)

// IsValid returns true if the PlanEntryPriority value is valid.
func (e PlanEntryPriority) IsValid() bool {
	switch e {
	case PlanEntryPriorityHigh, PlanEntryPriorityLow, PlanEntryPriorityMedium:
		return true
	default:
		return false
	}
}

// String returns the string representation of PlanEntryPriority.
func (e PlanEntryPriority) String() string {
	return string(e)
}

// MarshalJSON implements json.Marshaler for PlanEntryPriority.
func (e PlanEntryPriority) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid PlanEntryPriority value: %s", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler for PlanEntryPriority.
func (e *PlanEntryPriority) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	*e = PlanEntryPriority(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid PlanEntryPriority value: %s", s)
	}

	return nil
}

// AllPlanEntryPriorityValues returns all valid PlanEntryPriority values.
func AllPlanEntryPriorityValues() []PlanEntryPriority {
	return []PlanEntryPriority{
		PlanEntryPriorityHigh,
		PlanEntryPriorityLow,
		PlanEntryPriorityMedium,
	}
}

// Status of a plan entry in the execution flow. Tracks the lifecycle of each task from planning through completion. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryStatus string

// PlanEntryStatus constants
const (
	PlanEntryStatusCompleted  PlanEntryStatus = "completed"   // The task has been successfully completed.
	PlanEntryStatusInProgress PlanEntryStatus = "in_progress" // The task is currently being worked on.
	PlanEntryStatusPending    PlanEntryStatus = "pending"     // The task has not started yet.
)

// IsValid returns true if the PlanEntryStatus value is valid.
func (e PlanEntryStatus) IsValid() bool {
	switch e {
	case PlanEntryStatusCompleted, PlanEntryStatusInProgress, PlanEntryStatusPending:
		return true
	default:
		return false
	}
}

// String returns the string representation of PlanEntryStatus.
func (e PlanEntryStatus) String() string {
	return string(e)
}

// MarshalJSON implements json.Marshaler for PlanEntryStatus.
func (e PlanEntryStatus) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid PlanEntryStatus value: %s", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler for PlanEntryStatus.
func (e *PlanEntryStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	*e = PlanEntryStatus(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid PlanEntryStatus value: %s", s)
	}

	return nil
}

// AllPlanEntryStatusValues returns all valid PlanEntryStatus values.
func AllPlanEntryStatusValues() []PlanEntryStatus {
	return []PlanEntryStatus{
		PlanEntryStatusCompleted,
		PlanEntryStatusInProgress,
		PlanEntryStatusPending,
	}
}

// Reasons why an agent stops processing a prompt turn. See protocol docs: [Stop Reasons](https://agentclientprotocol.com/protocol/prompt-turn#stop-reasons)
type StopReason string

// StopReason constants
const (
	StopReasonCancelled       StopReason = "cancelled"         // The turn was cancelled by the client via `session/cancel`. This stop reason MUST be returned when the client sends a `session/cancel` notification, even if the cancellation causes exceptions in underlying operations. Agents should catch these exceptions and return this semantically meaningful response to confirm successful cancellation.
	StopReasonEndTurn         StopReason = "end_turn"          // The turn ended successfully.
	StopReasonMaxTokens       StopReason = "max_tokens"        // The turn ended because the agent reached the maximum number of tokens.
	StopReasonMaxTurnRequests StopReason = "max_turn_requests" // The turn ended because the agent reached the maximum number of allowed agent requests between user turns.
	StopReasonRefusal         StopReason = "refusal"           // The turn ended because the agent refused to continue. The user prompt and everything that comes after it won't be included in the next prompt, so this should be reflected in the UI.
)

// IsValid returns true if the StopReason value is valid.
func (e StopReason) IsValid() bool {
	switch e {
	case StopReasonCancelled, StopReasonEndTurn, StopReasonMaxTokens, StopReasonMaxTurnRequests, StopReasonRefusal:
		return true
	default:
		return false
	}
}

// String returns the string representation of StopReason.
func (e StopReason) String() string {
	return string(e)
}

// MarshalJSON implements json.Marshaler for StopReason.
func (e StopReason) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid StopReason value: %s", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler for StopReason.
func (e *StopReason) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	*e = StopReason(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid StopReason value: %s", s)
	}

	return nil
}

// AllStopReasonValues returns all valid StopReason values.
func AllStopReasonValues() []StopReason {
	return []StopReason{
		StopReasonCancelled,
		StopReasonEndTurn,
		StopReasonMaxTokens,
		StopReasonMaxTurnRequests,
		StopReasonRefusal,
	}
}

// Execution status of a tool call. Tool calls progress through different statuses during their lifecycle. See protocol docs: [Status](https://agentclientprotocol.com/protocol/tool-calls#status)
type ToolCallStatus string

// ToolCallStatus constants
const (
	ToolCallStatusCompleted  ToolCallStatus = "completed"   // The tool call completed successfully.
	ToolCallStatusFailed     ToolCallStatus = "failed"      // The tool call failed with an error.
	ToolCallStatusInProgress ToolCallStatus = "in_progress" // The tool call is currently running.
	ToolCallStatusPending    ToolCallStatus = "pending"     // The tool call hasn't started running yet because the input is either streaming or we're awaiting approval.
)

// IsValid returns true if the ToolCallStatus value is valid.
func (e ToolCallStatus) IsValid() bool {
	switch e {
	case ToolCallStatusCompleted, ToolCallStatusFailed, ToolCallStatusInProgress, ToolCallStatusPending:
		return true
	default:
		return false
	}
}

// String returns the string representation of ToolCallStatus.
func (e ToolCallStatus) String() string {
	return string(e)
}

// MarshalJSON implements json.Marshaler for ToolCallStatus.
func (e ToolCallStatus) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ToolCallStatus value: %s", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler for ToolCallStatus.
func (e *ToolCallStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	*e = ToolCallStatus(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ToolCallStatus value: %s", s)
	}

	return nil
}

// AllToolCallStatusValues returns all valid ToolCallStatus values.
func AllToolCallStatusValues() []ToolCallStatus {
	return []ToolCallStatus{
		ToolCallStatusCompleted,
		ToolCallStatusFailed,
		ToolCallStatusInProgress,
		ToolCallStatusPending,
	}
}

// Categories of tools that can be invoked. Tool kinds help clients choose appropriate icons and optimize how they display tool execution progress. See protocol docs: [Creating](https://agentclientprotocol.com/protocol/tool-calls#creating)
type ToolKind string

// ToolKind constants
const (
	ToolKindDelete  ToolKind = "delete"  // Removing files or data.
	ToolKindEdit    ToolKind = "edit"    // Modifying files or content.
	ToolKindExecute ToolKind = "execute" // Running commands or code.
	ToolKindFetch   ToolKind = "fetch"   // Retrieving external data.
	ToolKindMove    ToolKind = "move"    // Moving or renaming files.
	ToolKindOther   ToolKind = "other"   // Other tool types (default).
	ToolKindRead    ToolKind = "read"    // Reading files or data.
	ToolKindSearch  ToolKind = "search"  // Searching for information.
	ToolKindThink   ToolKind = "think"   // Internal reasoning or planning.
)

// IsValid returns true if the ToolKind value is valid.
func (e ToolKind) IsValid() bool {
	switch e {
	case ToolKindDelete, ToolKindEdit, ToolKindExecute, ToolKindFetch, ToolKindMove, ToolKindOther, ToolKindRead, ToolKindSearch, ToolKindThink:
		return true
	default:
		return false
	}
}

// String returns the string representation of ToolKind.
func (e ToolKind) String() string {
	return string(e)
}

// MarshalJSON implements json.Marshaler for ToolKind.
func (e ToolKind) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ToolKind value: %s", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler for ToolKind.
func (e *ToolKind) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	*e = ToolKind(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ToolKind value: %s", s)
	}

	return nil
}

// AllToolKindValues returns all valid ToolKind values.
func AllToolKindValues() []ToolKind {
	return []ToolKind{
		ToolKindDelete,
		ToolKindEdit,
		ToolKindExecute,
		ToolKindFetch,
		ToolKindMove,
		ToolKindOther,
		ToolKindRead,
		ToolKindSearch,
		ToolKindThink,
	}
}
